package code.NN;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;

/**
 * @author Alexandre Martens
 */
public class MathWork extends NeuralNet implements Serializable {

    /**
     * @param min minimum value in the range inclusive
     * @param max maximum value in the range exclusive
     * @return random number (pos or neg) in the given range
     */
    public static float random_initialisation(float min, float max) {
        float d = (float) Math.random();
        float number = min + (float) Math.random() * (max - min);

        if (d < 0.5)
            return number;
        else
            return -number;
    }

    /**
     * Doc: https://hackernoon.com/how-to-initialize-weights-in-a-neural-net-so-it-performs-well-3e9302d4490f
     *      https://medium.com/@prateekvishnu/xavier-and-he-normal-he-et-al-initialization-8e3d7a087528
     * @param input_neurons number of neurons of the previous layer
     * @return number generated by gaussian distribution
     */
    public static float he_et_al_initialisation(int input_neurons){
        Random rand = new Random();

        double number = (double) 2/input_neurons;
        return (float) (rand.nextGaussian() * Math.sqrt(number)); // Formula

    }


    /**
     * @param activation_function name of the activation function
     * @param sum the sum of all the weights*value + bias
     * @return activation value
     */
    public static float activationFunction(String activation_function, float sum){
        if (activation_function == "relu"){
            return relu(sum);
        } else if(activation_function == "sigmoid"){
            return sigmoid(sum);
        }
        return -1;
    }


    /** Sigmoid activation function
     * @param s input value we wanna squeeze between 0-1
     * @return squeezed s
     */
    private static float sigmoid(float s) {
        return (float) (1 / (1 + Math.pow(Math.E, -s)));
    }


    /** Relu activation function
     * @param s value for the relu funciton
     * @return floaat that is not negative
     */
    private static float relu(float s) {
        return (float) Math.max(0.0, s);
    }


    /**
     * @param activation_function name of the activation function
     * @param y value to derive
     * @return activation derivative value
     */
    public static float activationFunctionDerivative(String activation_function, float y){
        if(activation_function == "sigmoid")
            return sigmoidDerivative(y);
        else
            return reluDerivative(y);

    }


    /**
     * @param y value we want to derive
     * @return teh derivative of the sigmoid function
     */
    private static float sigmoidDerivative(float y) {
        return y * (1 - y);
    }


    /**
     * @param y value we want to derive
     * @return teh derivative of the relu function
     */
    private static float reluDerivative(float y) {
        if (y >= 0)
            return 1;
        else
            return 0;
    }


    /** Loss function SE for ARRAYS!
     * @param output takes an array with 1pos = 1 output
     * @param target takes an array with 1pos = 1 target
     * @return array with 1 pos = mse for that specific output pos and target pos
     */
    public static float[] squaredError(float[] output, float[] target) {
        float[] se = new float[output.length];

        for (int i = 0; i < se.length; i++){
            se[i] = (float) Math.pow((target[i] - output[i]),2); // Calc SE for every output-target pair
        }

        return se;
    }


    /** Perform the distance calc between the old state and the new one to check if the ball has advanced or not
     * @param xO Original x position of the agent in state S
     * @param yO Original y position of the agent in state S
     * @param xO_next next state x position of the agent in state S'
     * @param yO_next next state y position of the agent in state S'
     * @param xF x position flag
     * @param yF y position flag
     * @return gained distance between (S,flag) & (S', flag)
     */
    public static float distanceGain(float xO, float yO, float xO_next, float yO_next, float xF, float yF){

        // Calc distance original state to flag
        float deltaX =xF - xO;
        float deltaY = yF - yO;
        float distanceX0f = (float) Math.sqrt(Math.pow(deltaX,2) + Math.pow(deltaY,2));

        // Calc distance new state to flag
        float deltaX_next = xF - xO_next;
        float deltaY_next = yF - yO_next;
        float distanceX0_nextf = (float) Math.sqrt(Math.pow(deltaX_next,2) + Math.pow(deltaY_next,2));

        // Take the difference between the 2
        float distanceGained =  distanceX0f - distanceX0_nextf;

        return distanceGained;
    }


    /**
     * @return The the max index of an array
     */
    public static int getMaxIndex(float[] t){
        List<Float> list = new ArrayList<Float>();

        for (int i = 0; i < t.length; i++){
            list.add(t[i]);
        }
        return list.indexOf(Collections.max(list));
    }


    /**
     * @return The the max value of an array
     */
    public static Float getMaxValue(float[] t){
        List<Float> list = new ArrayList<Float>();

        for (int i = 0; i < t.length; i++){
            list.add(t[i]);
        }
        return Collections.max(list);
    }

}
